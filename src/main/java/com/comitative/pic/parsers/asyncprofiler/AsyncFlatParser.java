package com.comitative.pic.parsers.asyncprofiler;

import com.comitative.pic.MethodReference;
import com.comitative.pic.TimeRecord;
import com.comitative.pic.parsers.SnapshotParser;
import org.jetbrains.annotations.NotNull;

import com.intellij.openapi.diagnostic.Logger;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;

import java.util.regex.*;

/**
 * A simple parser for the flat report format as generated by the Async Profiler.
 *
 * The parser currently skips stack traces part and only collects information from the summary block.
 * This behavior may change in the future versions.
 */
public final class AsyncFlatParser implements SnapshotParser {

    private static final Logger log = Logger.getInstance(AsyncFlatParser.class);

    private static final String FORMAT_KEY = "async_profiler_flat";
    private static final String FORMAT_NAME = "Async Profiler flat snapshot";

    @Override
    public @NotNull String getFormatKey() {
        return FORMAT_KEY;
    }

    // FIXME: use a localized resource bundle
    @Override
    public @NotNull String getFormatName() {
        return FORMAT_NAME;
    }

    @Override
    public List<TimeRecord> parseStream(@NotNull InputStream inputStream) throws IOException {
        final List<TimeRecord> statistics = new LinkedList<>();
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        String line = reader.readLine();
        while (line != null) {
            parseSummaryLine(line).ifPresent(statistics::add);
            line = reader.readLine();
        }
        return statistics;
    }

    /**
     * Parse a summary line.
     *
     * This method is not a part of a public API and should be considered an implementation detail.
     * It has package visibility for testing purposes
     *
     * Expected format:
     * [absolute time: long, ns] [relative time:  double, %%]% [sample count: long] [method name, string]
     *
     * @param line line to parse
     * @return Optional pair (method reference, statistics), Optional.empty() if the line does not match the format
     */
    Optional<TimeRecord> parseSummaryLine(String line) {
        Matcher matcher = SUMMARY_LINE_PATTERN.matcher(line);
        if (matcher.matches()) {
            try {
                long absoluteTime = Long.parseLong(matcher.group(1));
                double relativeTime = normalizePercent(Double.parseDouble(matcher.group(2)));
                long sampleCount = Long.parseLong(matcher.group(3));
                return parseMethodName(matcher.group(4)).flatMap(methodRef -> {
                    TimeRecord timeRecord = new TimeRecord(methodRef, relativeTime);
                    timeRecord.setAbsoluteTime(absoluteTime);
                    timeRecord.setSampleCount(sampleCount);
                    return Optional.of(timeRecord);
                });
            } catch (NumberFormatException e) {
                log.warn("invalid numeric value: " + e.getMessage());
            }
        }
        return Optional.empty();
    }

    @NotNull Optional<MethodReference> parseMethodName(@NotNull String name) {
        return Optional.of(MethodReference.builder().setMethodName(name).build());
    }

    private static double normalizePercent(double percentValue) {
        if (percentValue < 0.0) {
            return 0.0;
        } else if (percentValue > 100.0) {
            return 1.0;
        } else {
            return percentValue / 100.0;
        }
    }

    private static final Pattern SUMMARY_LINE_PATTERN =
            Pattern.compile("^\\s*(\\d+)\\s+(\\d+\\.\\d+)%\\s+(\\d+)\\s+(.+)\\s*$");

}
