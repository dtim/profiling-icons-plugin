package com.comitative.pic.parsers;

import com.comitative.pic.CodeReference;
import com.comitative.pic.TimeRecord;
import org.jetbrains.annotations.NotNull;

import com.intellij.openapi.diagnostic.Logger;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;

import java.util.function.Function;
import java.util.regex.*;

/**
 * A simple parser for the flat report format as generated by the Async Profiler.
 *
 * The parser currently skips stack traces part and only collects information from the summary block.
 * This behavior may change in the future versions.
 */
public final class AsyncFlatParser extends SnapshotParser {

    private static final Logger log = Logger.getInstance(AsyncFlatParser.class);

    private static final String PARSER_LEY = "async_profiler_flat";
    private static final String PARSER_NAME = "Async Profiler flat snapshot";

    @Override
    public @NotNull String getKey() {
        return PARSER_LEY;
    }

    // FIXME: use a localized resource bundle
    @Override
    public @NotNull String getName() {
        return PARSER_NAME;
    }

    @Override
    public @NotNull List<TimeRecord> parseStream(@NotNull InputStream inputStream) throws IOException {
        final List<TimeRecord> statistics = new LinkedList<>();
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        String line = reader.readLine();
        while (line != null) {
            parseSummaryLine(line).ifPresent(statistics::add);
            line = reader.readLine();
        }
        return statistics;
    }

    /**
     * Parse a summary line.
     *
     * This method is not a part of a public API and should be considered an implementation detail.
     * It has package visibility for testing purposes
     *
     * Expected format:
     * [absolute time: long, ns] [relative time:  double, %%]% [sample count: long] [method name, string]
     *
     * @param line line to parse
     * @return Optional pair (method reference, statistics), Optional.empty() if the line does not match the format
     */
    Optional<TimeRecord> parseSummaryLine(String line) {
        Matcher matcher = SUMMARY_LINE_PATTERN.matcher(line);
        if (matcher.matches()) {
            try {
                long absoluteTime = Long.parseLong(matcher.group(1));
                double relativeTime = normalizePercent(Double.parseDouble(matcher.group(2)));
                long sampleCount = Long.parseLong(matcher.group(3));
                return parseMethodName(matcher.group(4)).flatMap(methodRef -> {
                    TimeRecord timeRecord = new TimeRecord(methodRef, relativeTime);
                    timeRecord.setAbsoluteTime(absoluteTime);
                    timeRecord.setSampleCount(sampleCount);
                    return Optional.of(timeRecord);
                });
            } catch (NumberFormatException e) {
                log.warn("invalid numeric value: " + e.getMessage());
            }
        }
        return Optional.empty();
    }

    /**
     * Parse name representations in the snapshot file and produce code references.
     *
     * @param name a name to parse.
     * @return an optional code reference, empty when the name is incorrect or should be ignored
     *
     * Notes:
     *   - This implementation of the parser uses a very simple string processing algorithm:
     *     split the name components by known separators and ignore the rest.
     *     This approach is very simple but not general enough to handle native names (e.g., JVM GC functions
     *     or system calls), method signatures etc. This simple parsing algorithm will be replaced with a more
     *     sophisticated parser based on Grammar Kit upon the completion of a better
     *     PSI/snapshot name matching algorithm.
     */
    @NotNull Optional<CodeReference> parseMethodName(@NotNull String name) {
        ArrayList<String> components = new ArrayList<>();
        int len = name.length();
        if (name.endsWith(JAVA_METHOD_MARKER)) {
            len -= JAVA_METHOD_MARKER_LENGTH;
        }

        int start = 0;
        while (start < len) {
            int sepIndex = takeUntil(name, start, len,
                    c -> NAME_SEPARATORS.contains(c)
                            || NATIVE_NAME_MARKERS.contains(c)
                            || c == '(');
            if (sepIndex < len) {
                char sep = name.charAt(sepIndex);
                if (NATIVE_NAME_MARKERS.contains(sep)) {
                    break;
                } else {
                    components.add(name.substring(start, sepIndex));
                    start = sepIndex + 1;
                    if (sep == '(') {
                        break;
                    }
                }
            } else {
                components.add(name.substring(start, len));
                break;
            }
        }

        int numComponents = components.size();
        if (numComponents >= 2) {
            CodeReference ref = CodeReference.builder()
                    .setMethodName(components.get(numComponents - 1))
                    .setQualifiedClassName(String.join(".", components.subList(0, numComponents - 1)))
                    .build();
            return Optional.of(ref);
        }

        return Optional.empty();
    }

    private int takeUntil(@NotNull String text, int start, int end, Function<Character, Boolean> predicate) {
        int i = start;
        while (i < end && !predicate.apply(text.charAt(i))) {
            i += 1;
        }
        return i;
    }

    private static double normalizePercent(double percentValue) {
        if (percentValue < 0.0) {
            return 0.0;
        } else if (percentValue > 100.0) {
            return 1.0;
        } else {
            return percentValue / 100.0;
        }
    }

    private static final Pattern SUMMARY_LINE_PATTERN =
            Pattern.compile("^\\s*(\\d+)\\s+(\\d+\\.\\d+)%\\s+(\\d+)\\s+(.+)\\s*$");

    private static final Set<Character> NAME_SEPARATORS = new TreeSet<>(Arrays.asList('.', '$'));
    private static final Set<Character> NATIVE_NAME_MARKERS = new TreeSet<>(Arrays.asList(':', '/'));

    private static final String JAVA_METHOD_MARKER = "_[j]";
    private static final int JAVA_METHOD_MARKER_LENGTH = JAVA_METHOD_MARKER.length();
}
