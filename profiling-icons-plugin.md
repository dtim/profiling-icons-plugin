---
title: "Profiling Statistics Icons Plugin"
author: "Dmitrii Timofeev"
fontsize: 12pt
geometry: margin=1in
papersize: a4paper
lang: russian
output:
  pdf_document:
    toc: yes
    keep_tex: yes
    fig_caption: yes
---

# Отображение времени исполнения методов

## Общие соображения о предметной области

Постановка задачи предполагает, что плагин должен читать результаты профилирования
программы из файла, который был сформирован произвольным способом без участия нашего
плагина.

Я некоторое время изучал, как выполняется профилирование приложений для JVM, что отдают
профайлеры и как пишутся плагины для IDEA. Сейчас пока я не готов написать полноценное
техническое задание — вместо этого я не очень формально опишу основные соображения,
которые повлияли на те или иные мои решения, и сами эти решения. В следующем разделе
я более компактно перечислю требования (или мои пожелания) к плагину — как я сам его
на данный момент вижу. Мне будет очень интересно обсудить эти соображения и пожелания,
чтобы понять, во-первых, насколько будущий плагин окажется удобным или неудобным для
пользователей, и, во-вторых, будет ли он служить своей цели как тестовое задание :).

### Форматы файлов

Async Profiler умеет экспортировать данные в "плоском" текстовом формате (который
очень похож на "плоский" формат gprof). Он содержит статистику вызова методов в двух
видах: с группировкой по методу и с группировкой по стеку вызовов. Возможно, в каких-то
ситуациях будет доступен только один из этих двух вариантов. Значения в блоке
с группировкой по методу можно вычислить, суммируя значения в тех записях блока
с группировкой по стеку, где на вершине стека находится соответствующий метод.

YourKit сохраняет результаты профилирования в своем внутреннем формате (возможно,
для него и есть документация, но я ее пока не нашел). Тем не менее, данные можно
экспортировать в CSV, XML, HTML, текстовое псевдографическое представление дерева
вызовов и, возможно, в какие-то еще форматы. Экспортированный вариант может
не содержать информации о доле времени, которая приходится на тот или иной
метод, но содержит данные об абсолютном количестве сэмплов для каждого метода,
так что вычислить процентные соотношения по этим данным нетрудно.
   
Еще один распространенный формат — JFR, бинарный формат Java Flight Recorder. 
Данные в нем умеет экспортировать как сам Java Flight Recorder, так и Async Profiler
(возможно, YourKit тоже умеет, но я пока не изучил). В этом формате записывается 
не обобщенная статистика, а последовательность событий. Из этого формата можно извлечь
нужную нам информацию, но может понадобиться несколько больше вычислений. Есть несколько
версий JFR (в частности, разные версии используются в разных версиях JDK), так что надо
разобраться, чем они отличаются друг от друга. Тем не менее, с помощью внешних библиотек
разобрать файл должно быть не очень сложно (можно использовать и методы JDK, но, вероятно,
возникнут вопросы в ситуации, когда версия JDK проекта не совпадает с версией JDK,
на которой выполняется плагин).
   
Из соображений простоты я хочу для начала научиться отображать данные из плоского
отчета Async Profiler. Затем можно будет добавить другие входные форматы:
  - экспортированные отчеты YourKit (по крайней мере CSV и XML),
  - логи событий JFR.

### Вызов плагина

Основной вариант — реакция на определенное действие (например, выбор пункта меню). 
Это проще всего, мы при этом никак не зависим от действий других плагинов, и можно
настроить окно выбора файла, как понадобится (в частности, можно попросить пользователя
указать, какой именно формат файла будет использоваться).
   
Можно также попытаться интегрироваться с обычным диалогом открытия файла. Это, наверное,
можно сделать двумя способами. Один вариант — связать наш плагин с определенным типом
файла и начинать работу, когда пользователь соответствующий файл открывает. Второй
вариант — интегрироваться с другими плагинами, которые могут загружать файлы со
статистикой профайлера, и выполнять определенные действия в качестве расширения.

Мне кажется, что оба расширенных варианта достаточно громоздкие. Других плагинов может
и не быть, а регистрировать новый тип файла — это, как мне кажется, может оказаться
не очень удобно (особенно в ситуации, когда у нас нет устоявшегося расширения/суффикса
для отчетов профайлера) Для JFR это могло бы пригодиться, но для остальных форматов
может быть неудобно для пользователя.
   
И главное — если мы хотим полноценно открывать файл, то хочется его показывать как-то 
более детально, чем просто в виде иконок в редакторе (например, список событий,
flame graph и так далее). Если этим заниматься, то фактически придется делать
полноценную визуализацию данных, а это будет долго.

Так что я бы для начала предпочел простое специализированное меню для одной
конкретной задачи.
         
### Источники данных

Если у нас есть какие-то другие плагины, которые умеют работать с профайлером 
(например, плагин YourKit), то может быть интересно получать от них информацию, 
чтобы оперативно обновлять статистику непосредственно в процессе работы профайлера 
или сразу после завершения сеанса профилирования.
   
Это кажется довольно трудоемкой задачей, так что в первой версии плагина этим 
не очень хочется заниматься. Но предусмотреть возможность того, что данные могут
приходить не только из файла, не помешает.
   
В общем случае может получиться так, что пользователь открывает файл, который
не соответствует проекту (или сильно устарел). В этом случае можно либо пытаться
что-то проверять (угадывать), либо просто показывать, что получится. Вариант
с проверками — это в любом случае гадание, так как отчет профайлера не содержит
метаданных, которые позволили бы надежно связывать отчеты с проектами. Поэтому
будем просто показывать, что получается.

Если статистика и проект не полностью соответствуют друг другу,
мне кажется логичным такой вариант.
  
  - Для конкретного метода нет данных о времени: просто ничего не показываем
    (это ничем не отличается от ситуации, когда метод просто ни разу не вызывали
    или он не попал ни в один сэмпл).
    
  - Данные не соответствуют действительности (например, они устарели или, если профиль
    вообще не соответствует проекту, имя метода случайно совпало): тоже показываем то,
    что нашли.
   
### Структура плагина

Для хранения результатов профилирования я предполагаю использовать сервис уровня проекта
(project-level service). Для начала можно ограничиться легковесным сервисом, который пока
что не будет доступен другим плагинам. Также понадобятся реализации Listener (также
project-level), которые будут реагировать на открытие документов (окон с исходным текстом
на Java или Kotlin). Возможно, будут нужны также классы для реакции на другие типы событий,
с этим мне еще надо будет разобраться (думаю, уже в ходе реализации).

Сервис хранения статистики должен предоставлять две основные операции.

  1. Возвращать долю времени, в течение которого выполнялся тот или иной метод
     (или, в общем случае, фрагмент кода). Здесь есть два варианта.
    
       1. Можно отталкиваться от исходного текста: когда пользователь открывает документ,
         мы смотрим на список методов, а затем для каждого из них запрашиваем у сервиса
         данные о времени выполнения. Если метод удалось найти — показываем иконку, если
         не удалось — пропускаем.
    
       2. Можно отталкиваться от статистики. Когда пользователь открывает документ,
          плагин находит в сервисе все записи, которые могут соответствовать этому документу
          (в частности, это методы, квалифицированное имя которых начинается с имени пакета
          и имени класса). Затем плагин отображает эти записи на строки в документе.
          Имена, которые отобразить не получилось, игнорируем. 
     
     > Мне на данный момент больше нравится второй вариант (он кажется чуть более эффективным
     и при этом более гибким, так как у нас могут быть записи, которые относятся к телу
     метода).
         
  2. Загружать статистику из внешнего источника (в первой версии плагина таким источником
     будет файл). (TODO: надо будет разобраться, как плагины взаимодействуют между собой.)
     
Для поддержки разных форматов понадобится интерфейс парсера и соответствующая фабрика.
Класс, реализующий файловый источник, должен будет на основе предоставленной пользователем
информации о типе файла (или с помощью автоопределения, где это возможно) запросить экземпляр
парсера для конкретного поддерживаемого типа файлов.

Некоторые соображения о соответствии имен в отчете профайлера и в исходном тексте описаны
в конце следующего раздела. Тем не менее, здесь я еще не принял какого-то окончательного
решения (это первоочередная задача).

### Иконки

Gutter icons играют две роли.
  - Отображают информацию.
  - Выполняют какое-то действие при взаимодействии пользователя с ними.
       
В нашем плагине:
  - отображаемая информация — это доля времени, в течение которого выполнялся
    именно этот метод;
  - действие: можно, например, открывать окно или подсказку, где показывать
    более детальную информацию о дереве вызовов, количестве сэмплов и так далее.
    Можно обойтись и без взаимодействия (при нажатии ничего не делать), но детальная
    информация из профайлера выглядит достаточно полезно.
       
В общем случае информация о времени может быть доступна не только для метода,
но и для отдельных элементов этого метода (блоков, операторов).
  - Профайлер считает те имена, которые были сгенерированы компилятором (например,
    лямбда-функции могут быть посчитаны как отдельные методы).
  - Некоторые профайлеры, возможно, могут дать дополнительную информацию о графе вызовов
    (например, сколько времени выполнялась каждая строка кода). 
    
В первой версии плагина ограничимся только методами, которые явно представлены 
в исходном тексте, не погружаясь внутрь соответствующего метода. При этом надо подумать,
как отчет профайлера соответствует тексту программы с учетом особенностей работы
компилятора (это, вероятно, будет особенно важно для Kotlin). Если в будущем захочется
поддерживать другие языки для JVM или IDE для других языков
(например, gprof + C (и особенно C++) в CLion).

С точки зрения структуры плагина, такая систематическая поддержка отображения исходного
текста программы на отчеты профайлера потребует дополнительной абстракции.
Это повлияет на интерфейс запроса статистики в сервисе (механизм отображения имен),
так что эту проблему придется решать в первую очередь.
     
# Требования

  1. Плагин должен поддерживать плоский текстовый формат Async Profiler.  
  2. Нужно предусмотреть возможность в будущем загружать данные в других форматах. Точно
     понадобится загружать плоские отчеты YourKit в CSV и XML, а также логи JFR.
  3. Загрузка статистики выполняется следующим образом.
     3.1. Пользователь выбирает пункт меню (условно "Загрузить результаты профилирования").
     3.2. Открывается окно, в котором пользователь должен указать файл и его формат.
     3.3. Когда пользователь предоставляет нужные данные и нажимает OK, плагин
          читает файл, парсит его и заменяет старую статистику (если есть)
          на новую.
  4. При открытии любого файла в проекте плагин отображает рядом с именами методов (как gutter icon)
     в этом файле долю времени, в течение которого этот метод выполнялся за все время
     профилирования. Если данные о конкретном методе недоступны, иконка рядом ним
     не отображается. Иконки могут также отображаться (возможно, с другим оформлением)
     рядом с некоторыми операторами (строками) в теле метода.
  4. Отображаемые данные не меняются, пока пользователь явно не загрузит новый файл.
  5. При нажатии на иконку отображается дополнительная информация о профиле исполнения
     метода (FIXME: нужно уточнить, что именно и как именно отображается).
     
# Пример исходных данных

Фрагмент отчета Async Profiler.

```
--- Execution profile ---
Total samples       : 8723

--- 49462082985 ns (56.70%), 4946 samples
  [ 0] com.comitative.pt.Matrix.multiply_[j]
  [ 1] com.comitative.pt.MainKt.main_[j]
  [ 2] com.comitative.pt.MainKt.main_[j]

--- 5770213383 ns (6.61%), 577 samples
  [ 0] com.comitative.pt.Matrix.getElement_[j]
  [ 1] com.comitative.pt.Matrix.multiply_[j]
  [ 2] com.comitative.pt.MainKt.main_[j]
  [ 3] com.comitative.pt.MainKt.main_[j]

--- 4270280415 ns (4.89%), 427 samples
  [ 0] com.comitative.pt.MainKt.main_[j]
  [ 1] com.comitative.pt.MainKt.main_[j]

--- 4020365757 ns (4.61%), 402 samples
  [ 0] com.comitative.pt.Transform.matrixToPoint_[j]
  [ 1] com.comitative.pt.Transform.transform_[j]
  [ 2] com.comitative.pt.MainKt.main_[j]
  [ 3] com.comitative.pt.MainKt.main_[j]

( ... skip ... )

          ns  percent  samples  top
  ----------  -------  -------  ---
 52322194795   59.97%     5232  com.comitative.pt.Matrix.multiply_[j]
 10000395944   11.46%     1000  com.comitative.pt.Matrix.getElement_[j]
  8420496037    9.65%      842  com.comitative.pt.MainKt.main_[j]
  4030366255    4.62%      403  com.comitative.pt.Transform.matrixToPoint_[j]

( ... skip ... )
```
